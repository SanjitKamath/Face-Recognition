# -*- coding: utf-8 -*-
"""Testing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cYzdsmPEcVIpdrejTKQocPCnd6ci7QX4
"""

!pip install mysql-connector-python
!apt-get -y install mysql-server
!service mysql start
!pip install cv2
!pip install dlib
!pip install numpy
!pip install pandas
!pip install mysql-connector-python

#!mysql -e "ALTER USER 'root'@'localhost' IDENTIFIED WITH 'mysql_native_password' BY 'root123';FLUSH PRIVILEGES;"
#!mysql -u root -p'root123' -e "CREATE DATABASE mydatabase;"
#!mysql -u root -p'root123' -e "USE mydatabase; CREATE TABLE attendance (id INT NOT NULL AUTO_INCREMENT, name VARCHAR(255) NOT NULL, time TIME NOT NULL, PRIMARY KEY (id));"

!mysql -u root -p'root123' -e "USE mydatabase; INSERT INTO attendance (name, time) VALUES (' Doe', '08:30:00');"
!mysql -u root -p'root123' -e "USE mydatabase; select * from attendance;"

import cv2
import matplotlib.pyplot as plt

config_file='ssd_mobilenet_v3_large_coco_2020_01_14.pbtxt'
frozen_model='frozen_inference_graph.pb'

model =cv2.dnn_DetectionModel(frozen_model,config_file)
classLabels = []
file_name="labels.txt"
with open(file_name,'rt') as fpt:
    classLabels=fpt.read().rstrip('\n').split('\n')

model.setInputSize(320,320)
model.setInputScale(1.0/127.5)
model.setInputMean((127.5,127,5,127.5))
model.setInputSwapRB(True)

img=cv2.imread("/content/known/group1.jpg")
plt.imshow(cv2.cvtColor(img,cv2.COLOR_BGR2RGB))
plt.show()

def detect_objects(img):
  ClassIndex,confidence,bbox=model.detect(img,confThreshold=0.5)
  font_scale=2
  font=cv2.QT_FONT_NORMAL
  for ClassInd,conf,boxes in zip(ClassIndex.flatten(),confidence.flatten(),bbox):
      #cv2.putText(img,classLabels[ClassInd-1],(boxes[0]+10,boxes[1]+40),font,fontScale=font_scale,color=(255,255,255),thickness=2)
      print(classLabels[ClassInd-1],(boxes[0]+10,boxes[1]+40))

  plt.imshow(cv2.cvtColor(img,cv2.COLOR_BGR2RGB))
  plt.show()
  cropped_images = crop_images(img,ClassIndex,confidence,bbox)
  return cropped_images

def crop_images(img,ClassIndex,confidence,bbox):

  # Create a list to store the person bounding boxes
  person_bboxes = []

  # Iterate through the detections
  for ClassInd, conf, boxes in zip(ClassIndex.flatten(), confidence.flatten(),bbox):
    # Check if the detected object is a person
    if classLabels[ClassInd - 1] == 'person':
        person_bboxes.append(boxes)

  # Crop the source image to only include the person bounding boxes
  cropped_images = []
  for bbox in person_bboxes:
    x, y, w, h = bbox
    cropped_img = img[y:y+h, x:x+w]
    cropped_images.append(cropped_img)

  # Display the cropped images
  for i, cropped_img in enumerate(cropped_images):
    plt.subplot(1, len(cropped_images), i+1)
    plt.imshow(cv2.cvtColor(cropped_img, cv2.COLOR_BGR2RGB))
    plt.title(f"Person {i+1}")
    plt.axis('off')

  plt.show()
  return cropped_images

cropped_imgs = detect_objects(img)

import dlib
import os
from datetime import datetime
import csv
import cv2
import numpy as np

detector = dlib.get_frontal_face_detector()
predictor = dlib.shape_predictor('shape_predictor_68_face_landmarks.dat')
face_rec_model = dlib.face_recognition_model_v1('dlib_face_recognition_resnet_model_v1.dat')

def load_known_faces(known_faces_dir):
    encodings = []
    names = []
    for filename in os.listdir(known_faces_dir):
        name = os.path.splitext(filename)[0]
        img = cv2.imread(os.path.join(known_faces_dir, filename))
        rgb_img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        for face in detector(rgb_img):
            shape = predictor(rgb_img, face)
            descriptor = np.array(face_rec_model.compute_face_descriptor(rgb_img, shape))
            encodings.append(descriptor)
            names.append(name)
    return encodings, names

known_face_encodings, known_face_names = load_known_faces("known")

def compare_faces(known_encodings, face_encoding, tolerance=0.6):
    distances = np.linalg.norm(known_encodings - face_encoding, axis=1)
    min_distance_index = np.argmin(distances)
    if distances[min_distance_index] < tolerance:
        return True, min_distance_index
    return False, None

# Initialize CSV output
csv_filename = "output.csv"
with open(csv_filename, mode='w', newline='') as file:
    writer = csv.writer(file)
    writer.writerow(['name', 'time'])

# Process each person image
for i, person_img in enumerate(cropped_imgs):
    person_img_rgb = cv2.cvtColor(person_img, cv2.COLOR_BGR2RGB)
    dets = detector(person_img_rgb)
    face_descriptors = []
    for d in dets:  # Use `d` within the loop
        shape = predictor(person_img_rgb, d)
        face_descriptor = face_rec_model.compute_face_descriptor(person_img_rgb, shape)
        face_descriptors.append(np.array(face_descriptor))

        with open(csv_filename, mode='a', newline='') as file:
            writer = csv.writer(file)
            for face_descriptor in face_descriptors:
                match, idx = compare_faces(known_face_encodings, face_descriptor)
                name = known_face_names[idx] if match else "Unknown"
                writer.writerow([name, datetime.now().strftime('%Y-%m-%d %H:%M:%S')])

                top, right, bottom, left = (d.top(), d.right(), d.bottom(), d.left())
                cv2.rectangle(person_img, (left, top), (right, bottom), (0, 0, 255), 2)
                cv2.putText(person_img, name, (left + 6, bottom - 6), cv2.FONT_HERSHEY_SIMPLEX, 1.0, (255, 255, 255), 1)

print(f"Detection results saved to {csv_filename}")

!service mysql start

import pandas as pd
import mysql.connector

# Load CSV file into a DataFrame
df = pd.read_csv('output.csv')

# Convert 'time' column to time format
df['time'] = pd.to_datetime(df['time']).dt.time

# Database connection
def get_db_connection():
    conn = mysql.connector.connect(
        host='localhost', #enter host of your system
        user='root',    #enter user of your system
        password='root123', #enter password of your system
        database='mydatabase'
    )
    return conn

# Insert data into MySQL
def insert_data(df):
    conn = get_db_connection()
    cur = conn.cursor()

    for index, row in df.iterrows():
        cur.execute(
            'INSERT INTO attendance (name, time) VALUES (%s, %s)',
            (row['name'], row['time'])
        )

    conn.commit()
    cur.close()
    conn.close()

# Run the insertion function
insert_data(df)

print("Data inserted successfully.")

!mysql -u root -p'root123' -e "USE mydatabase; select * from attendance;"